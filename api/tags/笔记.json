{"name":"笔记","postlist":[{"title":"用npm升级Hexo版本","slug":"用npm升级Hexo版本","date":"2024-10-19T09:00:00.000Z","updated":"2024-10-19T08:59:38.315Z","comments":true,"path":"api/articles/用npm升级Hexo版本.json","excerpt":null,"keywords":"Hexo, 科研, 生物, R语言, 爬虫, 生信, 中药, 果蝇, 笔记, 教程, 虫子, 潜叶虫, leafminer, leaf-miner, 生活, 随笔, 原创","cover":null,"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><div id=\"vip-container\"><p>使用npm命令简单快捷的升级Hexo，主题和插件的版本。</p>\n<h2 id=\"注意：\">注意：</h2>\n<p>更新主题和插件，会覆盖修改的内容，提前备份。Next主题配置文件’_config.next.yml’最好放在博客根目录下。</p>\n<span id=\"more\"></span> \n<h2 id=\"npm镜像服务器更换\">npm镜像服务器更换</h2>\n<p>国内的镜像服务器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 镜像服务器</span><br><span class=\"line\">npm config set registry https://registry.npmmirror.com</span><br><span class=\"line\"></span><br><span class=\"line\"># 更新npm</span><br><span class=\"line\">npm install -g npm@latest</span><br></pre></td></tr></table></figure>\n<h2 id=\"查看当前Hexo版本\">查看当前Hexo版本</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo --version</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装npm-check和npm-upgrade\">安装npm-check和npm-upgrade</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g npm-check</span><br><span class=\"line\">npm install -g npm-upgrade</span><br><span class=\"line\">npm-check</span><br></pre></td></tr></table></figure>\n<h2 id=\"升级Hexo\">升级Hexo</h2>\n<p>首先进入Hexo的主目录，执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 更新package.json</span><br><span class=\"line\">npm upgrade</span><br><span class=\"line\"></span><br><span class=\"line\">npm update</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\">参考</h2>\n<ol>\n<li class=\"lvl-3\">\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly91cHdub3RoaW5nLmdpdGh1Yi5pby96aC1DTi8zYmEzYmU5Lz9oaWdobGlnaHQ9aGV4bw==\">Hexo版本升级指南 | UPWNothing's Playground<i class=\"fa fa-external-link-alt\"></i></span></p>\n</li>\n<li class=\"lvl-3\">\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ucG1taXJyb3IuY29tLw==\">npmmirror 镜像站<i class=\"fa fa-external-link-alt\"></i></span></p>\n</li>\n</ol>\n</div>\n\n\t\t\t<script src=\"https://my.openwrite.cn/js/readmore.js\" type=\"text/javascript\"></script>\n\t\t\t<script>\n\t\t\tvar isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);\n\t\t\tif (!isMobile) {\n\t\t\t    var btw = new BTWPlugin();\n\t\t\t    btw.init({\n\t\t\t        \"id\": \"vip-container\",\n\t\t\t        \"blogId\": \"33502-1730425843713-524\",\n\t\t\t        \"name\": \"虫子的生存笔记\",\n\t\t\t        \"qrcode\": \"https://leaf-miner.pages.dev/image/%E5%85%AC%E4%BC%97%E5%8F%B7.png\",\n\t\t\t        \"keyword\": \"more\"\n\t\t\t    });\n\t\t\t}\n\t\t\t</script>\n\t\t","raw":null,"categories":[{"name":"笔记","path":"api/categories/笔记.json"},{"name":"笔记/学习","path":"api/categories/笔记/学习.json"}],"tags":[{"name":"Hexo","path":"api/tags/Hexo.json"},{"name":"Next","path":"api/tags/Next.json"},{"name":"博客","path":"api/tags/博客.json"},{"name":"笔记","path":"api/tags/笔记.json"},{"name":"升级","path":"api/tags/升级.json"}]},{"title":"Hexo博客Next主题添加algolia搜索","slug":"Hexo博客Next主题添加algolia搜索","date":"2024-10-17T16:17:01.000Z","updated":"2024-10-23T17:16:11.970Z","comments":true,"path":"api/articles/Hexo博客Next主题添加algolia搜索.json","excerpt":null,"keywords":"Hexo, 科研, 生物, R语言, 爬虫, 生信, 中药, 果蝇, 笔记, 教程, 虫子, 潜叶虫, leafminer, leaf-miner, 生活, 随笔, 原创","cover":"https://cdn.nlark.com/yuque/0/2024/png/12885947/1729186832132-e842bb62-33ef-4af4-816a-6ff74a4e093e.png","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><div id=\"vip-container\"><p>为Hexo博客系统中的Next主题添加Algolia搜索功能</p>\n<span id=\"more\"></span> \n<h2 id=\"注册Sign-in-Algolia\">注册<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kYXNoYm9hcmQuYWxnb2xpYS5jb20vdXNlcnMvc2lnbl9pbg==\">Sign in | Algolia<i class=\"fa fa-external-link-alt\"></i></span></h2>\n<p>​<img data-src=\"https://cdn.nlark.com/yuque/0/2024/png/12885947/1729186832132-e842bb62-33ef-4af4-816a-6ff74a4e093e.png\" alt=\"\">​</p>\n<p>新建一个Index，这里创建了一个名为leafminer-blog的索引。</p>\n<p>​<img data-src=\"https://cdn.nlark.com/yuque/0/2024/png/12885947/1729189311007-77eb9bbf-d16e-447f-9277-2e6a72d826c2.png\" alt=\"\">​</p>\n<h2 id=\"安装hexo-algolia\">安装hexo-algolia</h2>\n<p>hexo-algolia 是一个由社区提供的 Hexo 插件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save hexo-algolia</span><br></pre></td></tr></table></figure>\n<p>配置文件放在根目录下的<code>_config.yml</code>​中，而不是主题文件夹下的<code>_config.yml</code>​, 否则博客的搜索是搜索不到任何内容的，我们需要通过 <code>Hexo Aloglia</code>​ 获取站点数据。</p>\n<p>Hexo博客根目录下的<code>_config.yml</code>​中，配置如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">algolia:</span></span><br><span class=\"line\">  <span class=\"attr\">applicationID:</span> <span class=\"string\">&#x27;applicationID&#x27;</span> <span class=\"comment\">#Algolia Application ID</span></span><br><span class=\"line\">  <span class=\"attr\">apiKey:</span> <span class=\"string\">&#x27;apiKey&#x27;</span> <span class=\"comment\">#A Search-Only API key</span></span><br><span class=\"line\">  <span class=\"attr\">indexName:</span> <span class=\"string\">&#x27;...&#x27;</span> <span class=\"comment\">#The name of the Algolia index to use</span></span><br></pre></td></tr></table></figure>\n<p>​<img data-src=\"https://cdn.nlark.com/yuque/0/2024/png/12885947/1729189864115-05ef9ed2-2109-404e-9873-944be5d7d9ba.png\" alt=\"\">​</p>\n<h2 id=\"Hexo-Aloglia获取站点数据\">Hexo Aloglia获取站点数据</h2>\n<p>必须提供一个名为 <code>HEXO_ALGOLIA_INDEXING_KEY</code>​ 的环境变量作为单独的 API 密钥。创建它并赋予其以下有限的写访问权限：添加记录、删除记录、列出索引、删除索引。</p>\n<p>​<code>HEXO_ALGOLIA_INDEXING_KEY=[Write API Key]</code>​</p>\n<p>​<img data-src=\"https://cdn.nlark.com/yuque/0/2024/png/12885947/1729189817603-52e8f420-c000-440c-a885-3fd647366d62.png\" alt=\"\">​</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> HEXO_ALGOLIA_INDEXING_KEY=</span><br></pre></td></tr></table></figure>\n<p>​<img data-src=\"https://cdn.nlark.com/yuque/0/2024/png/12885947/1729190141176-9d66d152-ee3e-483c-8634-e9fb0064ba57.png\" alt=\"\">​</p>\n<p>使用插件提供的命令来推送你的内容到Algolia。在 <code>hexo</code>​站点根目录下执行<code>hexo algolia</code>​ 来搜集数据更新到我们刚创建的 <code>Index</code>​ 中,我们可以在网页中看到所有的数据，如下图：</p>\n<p>​<img data-src=\"https://cdn.nlark.com/yuque/0/2024/png/12885947/1729190857880-bf3194d8-0f7a-4db7-a81a-106321db1147.png\" alt=\"\">​</p>\n<h2 id=\"在Next主题中启用搜索功能\">在Next主题中启用搜索功能</h2>\n<p>确保在Next主题的配置文件中启用了Algolia搜索功能。这通常涉及到在<code>theme_config.yml</code>​中设置<code>algolia_search.enable</code>​为<code>true</code>​。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 在 NexT 主题的配置文件里</span></span><br><span class=\"line\"><span class=\"attr\">algolia_search:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">hits:</span></span><br><span class=\"line\">    <span class=\"attr\">per_page:</span> <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"重新部署\">重新部署</h2>\n<p>执行<code>hexo clean &amp;&amp; hexo g -d</code>​重新部署，部署完成后再次访问，即可看到搜索功能已经配置完成。</p>\n<h2 id=\"参考\">参考</h2>\n<ol>\n<li class=\"lvl-3\">\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8yMzQxNzU1\">hexo博客添加algolia搜索-腾讯云开发者社区-腾讯云 (tencent.com)<i class=\"fa fa-external-link-alt\"></i></span></p>\n</li>\n<li class=\"lvl-3\">\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ucG1qcy5jb20vaGV4by1hbGdvbGlhI2FwaS1rZXk=\">https://npmjs.com/hexo-algolia#api-key<i class=\"fa fa-external-link-alt\"></i></span></p>\n</li>\n</ol>\n</div>\n\n\t\t\t<script src=\"https://my.openwrite.cn/js/readmore.js\" type=\"text/javascript\"></script>\n\t\t\t<script>\n\t\t\tvar isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);\n\t\t\tif (!isMobile) {\n\t\t\t    var btw = new BTWPlugin();\n\t\t\t    btw.init({\n\t\t\t        \"id\": \"vip-container\",\n\t\t\t        \"blogId\": \"33502-1730425843713-524\",\n\t\t\t        \"name\": \"虫子的生存笔记\",\n\t\t\t        \"qrcode\": \"https://leaf-miner.pages.dev/image/%E5%85%AC%E4%BC%97%E5%8F%B7.png\",\n\t\t\t        \"keyword\": \"more\"\n\t\t\t    });\n\t\t\t}\n\t\t\t</script>\n\t\t","raw":null,"categories":[{"name":"笔记","path":"api/categories/笔记.json"},{"name":"笔记/其他","path":"api/categories/笔记/其他.json"}],"tags":[{"name":"Hexo","path":"api/tags/Hexo.json"},{"name":"Next","path":"api/tags/Next.json"},{"name":"搜索","path":"api/tags/搜索.json"},{"name":"博客","path":"api/tags/博客.json"},{"name":"笔记","path":"api/tags/笔记.json"},{"name":"algolia","path":"api/tags/algolia.json"}]},{"title":"Process-->Noise\\Filters笔记","slug":"ImageJ--图像去噪--Process中的Noise和Filters","date":"2024-06-11T13:53:40.000Z","updated":"2024-10-18T19:53:16.718Z","comments":true,"path":"api/articles/ImageJ--图像去噪--Process中的Noise和Filters.json","excerpt":null,"keywords":"Hexo, 科研, 生物, R语言, 爬虫, 生信, 中药, 果蝇, 笔记, 教程, 虫子, 潜叶虫, leafminer, leaf-miner, 生活, 随笔, 原创","cover":"./imgs/20240605_223251_00000.png","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><div id=\"vip-container\"><h1>Process–&gt;Noise\\Filters笔记</h1>\n<h2 id=\"Noise\">Noise</h2>\n<p><img data-src=\"./imgs/20240605_223251_00000.png\" alt=\"\"><br>\n<strong>Add noise</strong> 对图片增加随机噪声，噪声服从均值为0、标准差为25的高斯分布。<br>\n<strong>Add Specified Noise</strong> 增加一个均值为0、手动输入标准差的高斯噪声。</p>\n<span id=\"more\"></span> \n<p><strong>Salt and Pepper</strong> 通过随机替换2.5%的黑色像素和2.5%的白色像素来增加椒盐噪声。该命令仅适用于8-bit图片。<br>\n<strong>Despeckle</strong> 这是一种中值滤波器，它将像素值替换为它周围3*3的像素点的均值。中值滤波器对于去掉上面的椒盐噪声很有用。<br>\n<strong>Remove Outliers</strong> 如果一个像素点离它周围点的均值超过一定数值，该命令就会去除这个像素点。该命令对CCD相机的hot pixels或dead pixels很有用。</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\"><strong>Radius</strong>：决定计算均值的范围（单位是像素）。使用Process-Filter-Show Circular Masks来显示半径是如何转变为面积的。</li>\n<li class=\"lvl-2\"><strong>Threshold</strong>：决定阈值（单位是像素）</li>\n<li class=\"lvl-2\"><strong>Which Outliers</strong>：决定比均值更亮还是更暗的像素点去除。</li>\n</ul>\n<p><strong>Remove NANs</strong> 该滤波器将32-bit图片中的NaN像素点替换成由Radius定义的圆形kernel区域内部的像素点的平均值。<br>\n<strong>ROF Denoise</strong> 降噪</p>\n<h2 id=\"Filters\">Filters</h2>\n<p>该菜单包含五花八门的滤波器。<br>\n<strong>Convolve</strong> 使用填入文本区域的kernel进行空间卷积。一个kernel就是一个矩阵，它的中心是源像素，其他的元素是该像素的邻居。通过对像素点乘以相应的kernel中的系数然后相加得到结果。对kernel的尺寸没有限制，但它必须是方形，且必须是奇数宽度。勾选<code>Normalize Kernel</code>可以使得每个系数都除以所有系数的和，从而保持图片的亮度。<br>\n<strong>Gaussian Blur</strong> 该过滤器使用一个高斯函数进行卷积，从而实现平滑效果。<br>\n<strong>Gaussian Blur 3D</strong> 计算一个三维高斯低通滤波。<br>\n<strong>Median</strong> 将像素替换为周围点的平均像素值，从而实现<strong>降噪</strong>效果。<br>\n<strong>Mean</strong> 怎么感觉跟上面的Median是一个意思呢。<br>\n<strong>Minimum</strong> 将像素替换为周围点的最小值，从而实现灰度腐蚀。<br>\n<strong>Maximum</strong> 将像素替换为周围点的最大值，从而实现灰度膨胀。<br>\n<strong>Unsharp Mas</strong>k 通过从原图片中提出一个模糊的版本，从而锐化和加强边缘。<br>\n<strong>Variance</strong> 将每个像素替换为邻居的方差，从而高亮边缘。<br>\n<strong>Show Circular Masks</strong> 产生一个包含上面Median、Mean、Minimum、Maximum和Variance滤波器使用的圆形mask产生的事例。</p>\n<h2 id=\"参考\">参考</h2>\n<ol>\n<li class=\"lvl-3\">\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamluZ2VnZS53YW5nLzIwMjEvMTAvMDEvaW1hZ2VqLSVlNyU5NCVhOCVlNiU4OCViNyVlNiU4YyU4NyVlNSU4ZCU5Ny85Lw==\">https://www.jingege.wang/2021/10/01/imagej-用户指南/9/<i class=\"fa fa-external-link-alt\"></i></span></p>\n</li>\n</ol>\n</div>\n\n\t\t\t<script src=\"https://my.openwrite.cn/js/readmore.js\" type=\"text/javascript\"></script>\n\t\t\t<script>\n\t\t\tvar isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);\n\t\t\tif (!isMobile) {\n\t\t\t    var btw = new BTWPlugin();\n\t\t\t    btw.init({\n\t\t\t        \"id\": \"vip-container\",\n\t\t\t        \"blogId\": \"33502-1730425843713-524\",\n\t\t\t        \"name\": \"虫子的生存笔记\",\n\t\t\t        \"qrcode\": \"https://leaf-miner.pages.dev/image/%E5%85%AC%E4%BC%97%E5%8F%B7.png\",\n\t\t\t        \"keyword\": \"more\"\n\t\t\t    });\n\t\t\t}\n\t\t\t</script>\n\t\t","raw":null,"categories":[{"name":"笔记","path":"api/categories/笔记.json"},{"name":"笔记/学习","path":"api/categories/笔记/学习.json"}],"tags":[{"name":"插件","path":"api/tags/插件.json"},{"name":"笔记","path":"api/tags/笔记.json"},{"name":"ImageJ","path":"api/tags/ImageJ.json"},{"name":"图像","path":"api/tags/图像.json"},{"name":"降噪","path":"api/tags/降噪.json"},{"name":"Noise","path":"api/tags/Noise.json"},{"name":"Filters","path":"api/tags/Filters.json"}]},{"title":"Web API--学习笔记（1）","slug":"Web API--学习笔记（1）","date":"2024-05-28T16:00:00.000Z","updated":"2024-10-19T08:34:06.596Z","comments":true,"path":"api/articles/Web API--学习笔记（1）.json","excerpt":null,"keywords":"Hexo, 科研, 生物, R语言, 爬虫, 生信, 中药, 果蝇, 笔记, 教程, 虫子, 潜叶虫, leafminer, leaf-miner, 生活, 随笔, 原创","cover":null,"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><div id=\"vip-container\"><h2 id=\"简介\">简介</h2>\n<p>应用程序接口（<strong>API</strong>，Application Programming Interface）是基于编程语言构建的结构，使开发人员更容易地创建复杂的功能。它们抽象了复杂的代码，并提供一些简单的接口规则直接使用。</p>\n<span id=\"more\"></span> \n<blockquote>\n<p>通常分为两类：</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><strong>浏览器 API</strong>内置于 Web 浏览器中，能从浏览器和电脑周边环境中提取数据，并用来做有用的复杂的事情。例如<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0dlb2xvY2F0aW9uX0FQSQ==\">Geolocation API<i class=\"fa fa-external-link-alt\"></i></span>提供了一些简单的 JavaScript 结构以获得位置数据，因此你可以在 Google 地图上标示你的位置。在后台，浏览器确实使用一些复杂的低级代码（例如 C++）与设备的 GPS 硬件（或可以决定位置数据的任何设施）通信来获取位置数据并把这些数据返回给你的代码中使用浏览器环境；但是，这种复杂性通过 API 抽象出来，因而与你无关。</p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>第三方 API</strong>缺省情况下不会内置于浏览器中，通常必须在 Web 中的某个地方获取代码和信息。例如<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXYudHdpdHRlci5jb20vb3ZlcnZpZXcvZG9jdW1lbnRhdGlvbg==\">Twitter API<i class=\"fa fa-external-link-alt\"></i></span> 使你能做一些显示最新推文这样的事情，它提供一系列特殊的结构，可以用来请求 Twitter 服务并返回特殊的信息。</p>\n</li>\n</ul>\n<blockquote>\n<p>浏览器 API 类别</p>\n</blockquote>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><strong>操作文档的 API</strong>内置于浏览器中。最明显的例子是<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0RvY3VtZW50X09iamVjdF9Nb2RlbA==\">DOM（文档对象模型）<i class=\"fa fa-external-link-alt\"></i></span>API，它允许你操作 HTML 和 CSS — 创建、移除以及修改 HTML，动态地将新样式应用到你的页面，等等。每当你看到一个弹出窗口出现在一个页面上，或者显示一些新的内容时，这都是 DOM 的行为。你可以在在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9MZWFybi9KYXZhU2NyaXB0L0NsaWVudC1zaWRlX3dlYl9BUElzL01hbmlwdWxhdGluZ19kb2N1bWVudHM=\">Manipulating documents<i class=\"fa fa-external-link-alt\"></i></span>中找到关于这些类型的 API 的更多信息。</p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>从服务器获取数据的 API</strong> 用于更新网页的一小部分是相当好用的。这个看似很小的细节能对网站的性能和行为产生巨大的影响 — 如果你只是更新一个股票列表或者一些可用的新故事而不需要从服务器重新加载整个页面将使网站或应用程序感觉更加敏感和“活泼”。使这成为可能的 API 包括<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL1hNTEh0dHBSZXF1ZXN0\">XMLHttpRequest<i class=\"fa fa-external-link-alt\"></i></span>和<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0ZldGNoX0FQSQ==\">Fetch API<i class=\"fa fa-external-link-alt\"></i></span>。你也可能会遇到描述这种技术的术语<strong>Ajax</strong>。你可以在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9MZWFybi9KYXZhU2NyaXB0L0NsaWVudC1zaWRlX3dlYl9BUElzL0ZldGNoaW5nX2RhdGE=\">Fetching data from the server<i class=\"fa fa-external-link-alt\"></i></span>找到关于类似的 API 的更多信息。</p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>用于绘制和操作图形的 API</strong>目前已被浏览器广泛支持 — 最流行的是允许你以编程方式更新包含在 HTML <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas\"><canvas></a> 元素中的像素数据以创建 2D 和 3D 场景的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0NhbnZhc19BUEk=\">Canvas<i class=\"fa fa-external-link-alt\"></i></span>和<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL1dlYkdMX0FQSQ==\">WebGL<i class=\"fa fa-external-link-alt\"></i></span>。例如，你可以绘制矩形或圆形等形状，将图像导入到画布上，然后使用 Canvas API 对其应用滤镜（如棕褐色滤镜或灰度滤镜），或使用 WebGL 创建具有光照和纹理的复杂 3D 场景。这些 API 经常与用于创建动画循环的 API（例如<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL1dpbmRvdy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWU=\">window.requestAnimationFrame()<i class=\"fa fa-external-link-alt\"></i></span>）和其他 API 一起不断更新诸如动画和游戏之类的场景。</p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>音频和视频 API</strong> 例如 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0hUTUxNZWRpYUVsZW1lbnQ=\">HTMLMediaElement<i class=\"fa fa-external-link-alt\"></i></span>、<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL1dlYl9BdWRpb19BUEk=\">Web Audio API<i class=\"fa fa-external-link-alt\"></i></span> 和 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL1dlYlJUQ19BUEk=\">WebRTC<i class=\"fa fa-external-link-alt\"></i></span> 允许你使用多媒体来做一些非常有趣的事情，比如创建用于播放音频和视频的自定义 UI 控件，显示字幕字幕和你的视频，从网络摄像机抓取视频，通过画布操纵（见上），或在网络会议中显示在别人的电脑上，或者添加效果到音轨（如增益、失真、平移等） 。</p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>设备 API</strong>基本上是以对网络应用程序有用的方式操作和检索现代设备硬件中的数据的 API。我们已经讨论过访问设备位置数据的地理定位 API，因此你可以在地图上标注你的位置。其他示例还包括通过系统通知（参见<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL05vdGlmaWNhdGlvbnNfQVBJ\">Notifications API<i class=\"fa fa-external-link-alt\"></i></span>）或振动硬件（参见<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL1ZpYnJhdGlvbl9BUEk=\">Vibration API<i class=\"fa fa-external-link-alt\"></i></span>）告诉用户 Web 应用程序有用的更新可用。</p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>客户端存储 API</strong>在 Web 浏览器中的使用变得越来越普遍 - 如果你想创建一个应用程序来保存页面加载之间的状态，甚至让设备在处于脱机状态时可用，那么在客户端存储数据将会是非常有用的。例如使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL1dlYl9TdG9yYWdlX0FQSQ==\">Web Storage API<i class=\"fa fa-external-link-alt\"></i></span>的简单的键 - 值存储以及使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0luZGV4ZWREQl9BUEk=\">IndexedDB API<i class=\"fa fa-external-link-alt\"></i></span>的更复杂的表格数据存储。</p>\n</li>\n</ul>\n<blockquote>\n<p>第三方 API</p>\n</blockquote>\n<h2 id=\"API-如何工作？\">API 如何工作？</h2>\n<p>API 使用一个或多个 JavaScript objects 在你的代码中进行交互，这些对象用作 API 使用的数据（包含在对象属性中）的容器以及 API 提供的功能（包含在对象方法中）。</p>\n<h2 id=\"参考\">参考</h2>\n<ol>\n<li class=\"lvl-3\">\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9MZWFybi9KYXZhU2NyaXB0L0NsaWVudC1zaWRlX3dlYl9BUElzL0ludHJvZHVjdGlvbg==\">https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Introduction<i class=\"fa fa-external-link-alt\"></i></span></p>\n</li>\n<li class=\"lvl-3\">\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zc3BhaS5jb20vcG9zdC84Nzg4NSMh\">https://sspai.com/post/87885#!<i class=\"fa fa-external-link-alt\"></i></span></p>\n</li>\n</ol>\n</div>\n\n\t\t\t<script src=\"https://my.openwrite.cn/js/readmore.js\" type=\"text/javascript\"></script>\n\t\t\t<script>\n\t\t\tvar isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);\n\t\t\tif (!isMobile) {\n\t\t\t    var btw = new BTWPlugin();\n\t\t\t    btw.init({\n\t\t\t        \"id\": \"vip-container\",\n\t\t\t        \"blogId\": \"33502-1730425843713-524\",\n\t\t\t        \"name\": \"虫子的生存笔记\",\n\t\t\t        \"qrcode\": \"https://leaf-miner.pages.dev/image/%E5%85%AC%E4%BC%97%E5%8F%B7.png\",\n\t\t\t        \"keyword\": \"more\"\n\t\t\t    });\n\t\t\t}\n\t\t\t</script>\n\t\t","raw":null,"categories":[{"name":"笔记","path":"api/categories/笔记.json"},{"name":"笔记/学习","path":"api/categories/笔记/学习.json"}],"tags":[{"name":"博客","path":"api/tags/博客.json"},{"name":"笔记","path":"api/tags/笔记.json"},{"name":"API","path":"api/tags/API.json"},{"name":"建站","path":"api/tags/建站.json"}]},{"title":"ImageJ--形态学数据挖掘、三维建模以及图像拼接、配准、编辑和注释-TrakEM2简介","slug":"ImageJ--形态学数据挖掘、三维建模以及图像拼接、配准、编辑和注释-TrakEM2简介","date":"2024-05-16T09:02:40.000Z","updated":"2024-10-18T19:55:51.804Z","comments":true,"path":"api/articles/ImageJ--形态学数据挖掘、三维建模以及图像拼接、配准、编辑和注释-TrakEM2简介.json","excerpt":null,"keywords":"Hexo, 科研, 生物, R语言, 爬虫, 生信, 中药, 果蝇, 笔记, 教程, 虫子, 潜叶虫, leafminer, leaf-miner, 生活, 随笔, 原创","cover":null,"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><div id=\"vip-container\"><p>TrakEM2 是一个 ImageJ 插件，用于形态学数据挖掘、三维建模以及图像拼接、配准、编辑和注释。</p>\n<span id=\"more\"></span> \n<h2 id=\"设备要求\">设备要求</h2>\n<p>要运行 TrakEM2，该为 Fiji 的 JVM 分配多少内存？<br>\n取数据集中最大的单个二维图像，然后将其大小乘以 10，并确保 CPU 的每个内核至少有这么多可用内存。<br>\n例如，对于 4096x4096 16 位图像，每个内核至少需要 335 Mb，因此 16 个内核至少需要 5.4 Gb 内存。8 Gb 可能会更好。32GB 的内存使用起来会很方便。<br>\n至于显卡，在计算能力和内置内存方面都要买你能负担得起的最大显卡。</p>\n<h2 id=\"特征\">特征</h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p><strong>特征分割：</strong> 在堆栈(stack)上手动绘制区域，用球和管道勾勒结构。骨架化整个神经元轴突，用关系连接器对象表示突触。</p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>测量：</strong> 体积、表面、长度，以及通过 ImageJ ROI 进行测量。</p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>图像配准：</strong> 使用 SIFT 和全局优化算法将浮动图块相互配准。</p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>三维可视化：</strong> 通过与三维浏览器插件交互，TrakEM2 可显示图像体积和各种三维网格。</p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>图像注释：</strong> 浮动文本标签。</p>\n</li>\n<li class=\"lvl-2\">\n<p><strong>语义分割：</strong> 以树状层次排列分割，其模板可导出供其他类似项目重复使用。</p>\n</li>\n</ul>\n<h2 id=\"\"></h2>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>通过 &quot;File - New - TrakEM2 (blank)&quot;创建新项目</p>\n</li>\n<li class=\"lvl-2\">\n<p>通过将 .xml 文件拖到工具栏上或通过 &quot;文件 - 打开 &quot;打开现有项目。</p>\n</li>\n</ul>\n<h2 id=\"TrakEM2最佳性能设定\">TrakEM2最佳性能设定</h2>\n<h3 id=\"加快图层浏览\">加快图层浏览</h3>\n<p>右键单击画布，选择 “Display - Properties…”。然后确保</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>&quot;snapshots mode &quot;设置为 “Disabled”，或最多设置为 “Outlines”。</p>\n</li>\n<li class=\"lvl-2\">\n<p>取消&quot;Prepaint&quot;，使其处于禁用状态。</p>\n</li>\n</ul>\n<h3 id=\"导入大量图像，并在导入后立即进行编辑\">导入大量图像，并在导入后立即进行编辑</h3>\n<p>避免多次生成 mip，不启用 “enable mipmaps”，使其处于禁用状态。由于不会生成贴图，将无法在导入时快速浏览图层。现在要纠正对比度，首先要重新启用 mipmaps，方法是：&quot;Display - Properties&quot;并选中 “enable mipmaps” 复选框。然后有两个（非排他性）选项：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>A. 使用右键菜单中的内置命令，例如</p>\n<ul class=\"lvl-2\">\n<li class=\"lvl-6\">“Adjust images - Enhance contrast layer-wise”</li>\n<li class=\"lvl-6\">“Adjust images - Set min and max layer-wise”。</li>\n</ul>\n</li>\n<li class=\"lvl-2\">\n<p>B. 创建一个预处理器脚本并将其设置为所有图像。例如，在每个图像上运行 CLAHE 的 beanshell 脚本。在脚本中，patch 和 imp 变量自动存在，分别代表 Patch 实例和 Patch 封装的 ImagePlus 实例。</p>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ij.IJ;</span><br><span class=\"line\">IJ.run(imp, <span class=\"string\">&quot;Enhance Local Contrast (CLAHE)&quot;</span>, <span class=\"string\">&quot;blocksize=127&quot;</span></span><br><span class=\"line\">   + <span class=\"string\">&quot; histogram=256 maximum=3 mask=*None* fast_(less_accurate)&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>要将脚本设置为所有图像，请将上述内容保存到名为 “whatever.bsh “的文件中（注意文件名扩展名为”.bsh”），然后右键单击 TrakEM2 画布，选择 “Script - Set preprocessor script layer-wise”，并选择整个图层范围。这会将脚本设置到每个图层的每个图像上，并触发每个图像的 mipmap 再生。当 TrakEM2 加载图像时，脚本将在 TrakEM2 看到图像内容之前在图像上运行。</p>\n<h3 id=\"快速重新生成-mipmap\">快速重新生成 mipmap</h3>\n<p>mipmap 的默认生成方式是平均生成，速度相当快。不过，还可以考虑将其并行化：进入 “Project - Properties…”，将 mipmap 线程数设置为您机器的内核数，例如 12。如果选择使用高斯模式生成 mipmaps，请进入 “Project - Properties…”，将 mipmaps 模式设置为 “Gaussian”。必须注意以下事项：<br>\n在 TrakEM2 0.9a 及更高版本中，mipmaps 机器可以使用最新 ImageJ 中的多线程高斯实现。这意味着现在有两组线程：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>线程集，每个线程重新生成单张图像的 mipmap 金字塔。</p>\n</li>\n<li class=\"lvl-2\">\n<p>在生成 mipmap 金字塔的过程中，每迭代一次缩放，就会有一组线程执行高斯模糊降采样。</p>\n</li>\n</ul>\n<p>如果您的机器有 12 个内核，默认设置将使用 1 个线程处理 mipmap，12 个线程处理高斯模糊。这可能不符合您的数据属性：如果图像较小，您可能需要等待很长时间才能生成 mipmap。有两种策略可以加速基于高斯的 mipmaps 生成：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>策略 A：您的数据由大图像组成（超过 4000x4000）。右键单击 TrakEM2 显示屏，选择 “Project - Properties…”，将 mipmap 线程设置为 1（默认值）。现在，将使用 12 个线程（给定 12 个内核）计算高斯，每次为单个图像重新生成 mipmap。</p>\n</li>\n<li class=\"lvl-2\">\n<p>策略 B：您的数据由小图像组成（小于 4000x4000）。进入 Fiji 窗口，选择 “Edit - Options - Memory &amp; Threads…”，将线程数设为 1。 然后进入 “Project - Properties…”，将 mipmap 线程数设为 12。现在，mipmap 将一次生成 12 幅图像（给定 12 个内核），每幅图像使用一个线程计算高斯。</p>\n</li>\n</ul>\n<p>如果您的电脑内存较少，或者访问图像的速度较慢（例如数据保存在 USB 硬盘中），也可以使用策略 A。这就是为什么默认情况下只用一个线程生成 mipmaps。<br>\n如果将生成 mipmaps 的方法改为非高斯方法，就不会出现上述情况。将生成 mipmaps 的线程数设置为内核数，如果电脑内存不多，则设置为更少的线程数。</p>\n<h3 id=\"使用更大的quadtree-buckets，XML-加载更快，内存消耗更少\">使用更大的quadtree buckets，XML 加载更快，内存消耗更少</h3>\n<p>除了为大图像选择合适的 mipmap 生成策略外，还要确保适当设置bucket的大小。<br>\n<strong>什么是 TrakEM2 中的 “bucket”：</strong> 每个层（每个部分）都有一个内部四叉树，用于查找鼠标下的对象（如图像），或快速查找与其他图像重叠的图像。换句话说，就是能够执行快速空间查询，例如查找与给定矩形相交的所有图像列表。<br>\n如果图像bucket的尺寸很小（默认边长为 4096 像素，那么一个图像桶就是一个 4096x4096 像素的正方形，这可以说是相当小了），再加上画布尺寸很大，生成的图像桶就会太多。这将耗费大量时间和内存。如果您的每个部分只有大约 100 张图片，而且图片都比较大（例如，每张图片的尺寸为 8096x8096 像素），那么请将bucket大小设置为比默认值大得多的值，例如 100000。这样实际上就只有一个bucket了。<br>\n当一个图层中有许多小对象或许多小的 zdisplayable 对象时，就需要使用小的数据bucket。在这种情况下，例如每个图层只有一个图像，但其中有许多较小的 Ball 或 Pipe 或 AreaList 对象，那么可以使用默认的数据bucket大小（4096）或更小。否则，可以选择大尺寸甚至超大尺寸，这样就能有效地移除bucket功能，并简化为列表搜索，而列表搜索对于 100 张左右的小图像列表来说是没有问题的。    在配准/对齐分布在 5000 个部分的 400,000 张图片时，将图片桶设置为大（如 40960，默认值的 10 倍，甚至更大）是合理的。    将数据bucket大小设置为较大值将大大减少 XML 的加载时间。    要设置数据bucket大小，请右键单击并选择 “Display - Properties …”，然后写入数据桶大小值。</p>\n<h2 id=\"TrakEM2-一些脚本\">TrakEM2 一些脚本</h2>\n<p>打开 “Plugins - Scripting - Jython Interpreter”（请参阅 “<span class=\"exturl\" data-url=\"aHR0cHM6Ly9pbWFnZWoubmV0L3NjcmlwdGluZw==\">脚本帮助<i class=\"fa fa-external-link-alt\"></i></span>”），确保打开了 TrakEM2 项目，并打开显示图片。然后键入或粘贴下面的示例。或者使用 &quot;File - New - Script&quot;打开一个新的脚本编辑器窗口，然后粘贴示例，选择 “Language - Python”，并按下 &quot;Run &quot;按钮。基础：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>拖动图像并将其可视化的画布是显示对象的一部分。后者拥有访问其 &quot;选区 &quot;以及 &quot;显示 &quot;正在查看的 &quot;图层 &quot;和 &quot;图层集 &quot;的方法。</p>\n</li>\n<li class=\"lvl-2\">\n<p>图层包含 Patch（每个 Patch 都包裹着一幅图像）和 DLabel（浮动文本）等 2D 对象。</p>\n</li>\n<li class=\"lvl-2\">\n<p>LayerSet 包含三维对象，如 AreaList、Pipe、Polyline、Ball、Dissector、Treeline 和 Stack（后者封装了包含 ij.ImageStack 的 ij.ImagePlus）。</p>\n</li>\n</ul>\n<h3 id=\"获取所选图像实例\">获取所选图像实例</h3>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>p = Display.getFront().getActive()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> p</span><br><span class=\"line\">    090504_0314_ex0768.mrc z=<span class=\"number\">0.0</span> <span class=\"comment\">#67398</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"获取选定图像的ImagePlus\">获取选定图像的ImagePlus</h3>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>p = Display.getFront().getActive()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>imp = p.getImagePlus()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> imp.width, imp.height</span><br><span class=\"line\">    <span class=\"number\">2048</span> <span class=\"number\">2048</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"访问图层和选择显示\">访问图层和选择显示</h2>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>front = Display.getFront()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>layer = front.getLayer()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>layer_set = front.getLayerSet()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sel = front.getSelection()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span> sel.getSelected().size()</span><br><span class=\"line\">    <span class=\"number\">10</span></span><br><span class=\"line\">    &gt;&gt;&gt; <span class=\"built_in\">print</span> sel.isEmpty()</span><br><span class=\"line\">    <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\">参考</h2>\n<ol>\n<li class=\"lvl-3\">\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pbWFnZWoubmV0L3BsdWdpbnMvdHJha2VtMi8=\">https://imagej.net/plugins/trakem2/<i class=\"fa fa-external-link-alt\"></i></span></p>\n</li>\n<li class=\"lvl-3\">\n<p>Cardona, A., Saalfeld, S., Schindelin, J., Arganda-Carreras, I., Preibisch, S., Longair, M., … Douglas, R. J. (2012). TrakEM2 Software for Neural Circuit Reconstruction. PLoS ONE, 7(6), e38011. doi:10.1371/journal.pone.0038011</p>\n</li>\n<li class=\"lvl-3\">\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zeW4ubXJjLWxtYi5jYW0uYWMudWsvYWNhcmRvbmEvSU5JLTIwMDgtMjAxMS9kYXRhLmh0bWw=\">https://syn.mrc-lmb.cam.ac.uk/acardona/INI-2008-2011/data.html<i class=\"fa fa-external-link-alt\"></i></span></p>\n</li>\n</ol>\n</div>\n\n\t\t\t<script src=\"https://my.openwrite.cn/js/readmore.js\" type=\"text/javascript\"></script>\n\t\t\t<script>\n\t\t\tvar isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);\n\t\t\tif (!isMobile) {\n\t\t\t    var btw = new BTWPlugin();\n\t\t\t    btw.init({\n\t\t\t        \"id\": \"vip-container\",\n\t\t\t        \"blogId\": \"33502-1730425843713-524\",\n\t\t\t        \"name\": \"虫子的生存笔记\",\n\t\t\t        \"qrcode\": \"https://leaf-miner.pages.dev/image/%E5%85%AC%E4%BC%97%E5%8F%B7.png\",\n\t\t\t        \"keyword\": \"more\"\n\t\t\t    });\n\t\t\t}\n\t\t\t</script>\n\t\t","raw":null,"categories":[{"name":"笔记","path":"api/categories/笔记.json"},{"name":"笔记/学习","path":"api/categories/笔记/学习.json"}],"tags":[{"name":"笔记","path":"api/tags/笔记.json"},{"name":"ImageJ","path":"api/tags/ImageJ.json"},{"name":"图像配准","path":"api/tags/图像配准.json"},{"name":"图像拼接","path":"api/tags/图像拼接.json"},{"name":"TrakEM2","path":"api/tags/TrakEM2.json"},{"name":"简介","path":"api/tags/简介.json"}]},{"title":"R语言--SimpleITK","slug":"R语言-SIMPLEITK","date":"2024-05-16T09:02:40.000Z","updated":"2024-10-18T19:40:58.802Z","comments":true,"path":"api/articles/R语言-SIMPLEITK.json","excerpt":null,"keywords":"Hexo, 科研, 生物, R语言, 爬虫, 生信, 中药, 果蝇, 笔记, 教程, 虫子, 潜叶虫, leafminer, leaf-miner, 生活, 随笔, 原创","cover":null,"content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><div id=\"vip-container\"><p><strong>SimpleITK</strong> 是 Insight 工具包（ITK）算法和数据结构的简化编程接口。它支持多种编程语言的接口，包括 C++、Python、R、Java、C#、Lua、Ruby 和 TCL。这些绑定使科学家能够用他们最熟悉的编程语言开发图像分析工作流。该工具包支持 15 种以上不同的图像文件格式，提供 280 多种图像分析过滤器，并为 ITK 基于强度的配准框架实现了统一接口。</p>\n<span id=\"more\"></span>\n<h2 id=\"特点\">特点</h2>\n<p>使用 Python、R、Java、C#、Lua、Ruby、TCL 和 C++ 进行开源多维图像分析。由 Insight 工具包社区为生物医学科学及其他领域开发。</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">被视为空间对象而非像素阵列的图像。计算在二维或三维物理空间中进行。</li>\n<li class=\"lvl-2\">利用刚性或可变形变换快速配准二维和三维模内和模间图像的配准框架。</li>\n<li class=\"lvl-2\">从经典的Otsu thresholding到水平集(level sets) 和分水岭(watersheds)，为图像分割工作流程提供了丰富的过滤器。</li>\n<li class=\"lvl-2\">评估分割结果（豪斯多夫距离、雅卡德值和骰子值、表面距离等&lt;Hausdorff distance, Jaccard and Dice values, surface distances etc.&gt; ）和分析分割形状特征（定向边界框、主矩、周长、伸长率、费雷特直径等&lt;oriented bounding box, principal moments, perimeter, elongation, Feret diameter etc.&gt;）的工具。</li>\n<li class=\"lvl-2\">图像文件输入/输出，支持 20 多种图像文件格式（jpg、png、DICOM、TIFF 等），并可在不同格式间轻松转换。</li>\n<li class=\"lvl-2\">通过基于进程和线程的并行化，可随时集成到集群或台式机的并行处理框架中。</li>\n</ul>\n<h2 id=\"安装R包-SimpleITKRInstaller\">安装R包-SimpleITKRInstaller</h2>\n<p><code>devtools::install_github(&quot;SimpleITK/SimpleITKRInstaller&quot;)</code></p>\n<h2 id=\"Fiji\">Fiji</h2>\n<p>SimpleITK 有一个内置函数 <code>itk::simple::Show()</code>，可用于在交互会话中查看图像。默认情况下，该 Show 函数会搜索已安装的 Fiji 来显示图像。如果找不到 Fiji，则会搜索 ImageJ。选择 Fiji/ImageJ 是因为它们可以处理 SimpleITK 支持的所有图像类型，包括每像素有 n 个分量的 3D 矢量图像。    Show 函数会在多个标准位置搜索 Fiji/ImageJ。具体位置取决于系统类型（Linux、Mac 或 Windows）。启用 &quot;Show &quot;的 &quot;debugOn &quot;选项后，用户可以看到 SimpleITK 正在搜索 Fiji（或其他查看应用程序）的位置，以及用于启动查看应用程序的实际命令。    Show 是 ImageViewer 类的功能接口。可以使用 ImageViewer 对象配置其他查看应用程序.</p>\n<hr>\n<h2 id=\"图片导入和导出\">图片导入和导出</h2>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>SimpleITK<span class=\"punctuation\">)</span></span><br><span class=\"line\"></span><br><span class=\"line\">reader <span class=\"operator\">&lt;-</span> ImageFileReader<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">reader<span class=\"operator\">$</span>SetImageIO<span class=\"punctuation\">(</span><span class=\"string\">&quot;PNGImageIO&quot;</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">reader<span class=\"operator\">$</span>SetFileName<span class=\"punctuation\">(</span>inputImageFileName<span class=\"punctuation\">)</span></span><br><span class=\"line\">image <span class=\"operator\">&lt;-</span> reader<span class=\"operator\">$</span>Execute<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span></span><br><span class=\"line\"></span><br><span class=\"line\">writer <span class=\"operator\">&lt;-</span> ImageFileWriter<span class=\"punctuation\">(</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">writer<span class=\"operator\">$</span>SetFileName<span class=\"punctuation\">(</span>outputImageFileName<span class=\"punctuation\">)</span></span><br><span class=\"line\">writer<span class=\"operator\">$</span>Execute<span class=\"punctuation\">(</span>image<span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n<p>上面的示例指定使用 PNGImageIO 来读取文件。如果省略该行，SimpleITK 将根据文件名的后缀和/或文件头自动确定要使用哪个 IO。</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">image <span class=\"operator\">&lt;-</span> ReadImage<span class=\"punctuation\">(</span>inputImageFileName<span class=\"punctuation\">)</span></span><br><span class=\"line\">WriteImage<span class=\"punctuation\">(</span>image<span class=\"punctuation\">,</span> outputImageFileName<span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n</div>\n\n\t\t\t<script src=\"https://my.openwrite.cn/js/readmore.js\" type=\"text/javascript\"></script>\n\t\t\t<script>\n\t\t\tvar isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);\n\t\t\tif (!isMobile) {\n\t\t\t    var btw = new BTWPlugin();\n\t\t\t    btw.init({\n\t\t\t        \"id\": \"vip-container\",\n\t\t\t        \"blogId\": \"33502-1730425843713-524\",\n\t\t\t        \"name\": \"虫子的生存笔记\",\n\t\t\t        \"qrcode\": \"https://leaf-miner.pages.dev/image/%E5%85%AC%E4%BC%97%E5%8F%B7.png\",\n\t\t\t        \"keyword\": \"more\"\n\t\t\t    });\n\t\t\t}\n\t\t\t</script>\n\t\t","raw":null,"categories":[{"name":"笔记","path":"api/categories/笔记.json"},{"name":"笔记/学习","path":"api/categories/笔记/学习.json"}],"tags":[{"name":"插件","path":"api/tags/插件.json"},{"name":"笔记","path":"api/tags/笔记.json"},{"name":"ImageJ","path":"api/tags/ImageJ.json"},{"name":"图像","path":"api/tags/图像.json"},{"name":"简介","path":"api/tags/简介.json"}]},{"title":"RNA-Seq Count数据的标准化(RPKM, FPKM, TPM)-学习笔记","slug":"RNA-Seq Count数据的标准化(RPKM, FPKM, TPM)-学习笔记","date":"2023-09-21T07:37:35.000Z","updated":"2024-10-19T08:32:10.893Z","comments":true,"path":"api/articles/RNA-Seq Count数据的标准化(RPKM, FPKM, TPM)-学习笔记.json","excerpt":null,"keywords":"Hexo, 科研, 生物, R语言, 爬虫, 生信, 中药, 果蝇, 笔记, 教程, 虫子, 潜叶虫, leafminer, leaf-miner, 生活, 随笔, 原创","cover":"https://thereallda.github.io/2022/01/24/%E7%90%86%E8%AE%BA-%E7%AE%80%E8%BF%B0RPKM-FPKM-AND-TPM/image-20220124111816290.png","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><div id=\"vip-container\"><p>测序得到的 <strong>read counts</strong> 数量会受到多种因素的影响，如 <strong>测序深度</strong> 和 <strong>基因长度</strong> 。除了上述两个主要因素外，还会有其他因素对read counts的检测有所影响，例如转录组的组成，GC含量，random hexamers引起的测序偏好等等。因此测序得到的read counts需要标准化后才能进行比较。标准化的方式有 <strong>RPKM</strong> ， <strong>FPKM</strong>， <strong>TPM</strong> 。其中TPM被更多人认可。</p>\n<span id=\"more\"></span> \n<p><strong>RPKM:</strong> Reads per kilo base per million mapped reads (single-end sequencing)</p>\n<p><strong>FPKM:</strong> Fragments per kilo base per million mapped reads (paired-end sequencing)</p>\n<p>RPKM与FPKM实际上一样的单位，只不过RPKM是在单端测序文库中使用，而FPKM是双端测序所用的。对基因长度（gene length）以及测序深度（mapped reads from library）都进行了校正。<br>\n<img data-src=\"https://thereallda.github.io/2022/01/24/%E7%90%86%E8%AE%BA-%E7%AE%80%E8%BF%B0RPKM-FPKM-AND-TPM/image-20220124111816290.png\" alt=\"公式1\"></p>\n<h3 id=\"RPKM，FPKM\">RPKM，FPKM</h3>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#x为一个向量存储了每个基因的counts，而gene.length是相应于x中每个基因的长度的一个向量.</span></span><br><span class=\"line\">RPKM <span class=\"operator\">&lt;-</span> <span class=\"keyword\">function</span><span class=\"punctuation\">(</span>x<span class=\"punctuation\">,</span> gene.length<span class=\"punctuation\">)</span><span class=\"punctuation\">&#123;</span> </span><br><span class=\"line\">  lib.size <span class=\"operator\">&lt;-</span> <span class=\"built_in\">sum</span><span class=\"punctuation\">(</span>x<span class=\"punctuation\">)</span></span><br><span class=\"line\">  rpm <span class=\"operator\">&lt;-</span> 1e6 <span class=\"operator\">*</span> x<span class=\"operator\">/</span>lib.size</span><br><span class=\"line\">  rpkm <span class=\"operator\">&lt;-</span> 1e3 <span class=\"operator\">*</span> rpm<span class=\"operator\">/</span>gene.length</span><br><span class=\"line\">  <span class=\"built_in\">return</span><span class=\"punctuation\">(</span>rpkm<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">FPKM <span class=\"operator\">&lt;-</span> <span class=\"keyword\">function</span><span class=\"punctuation\">(</span>x<span class=\"punctuation\">,</span> gene.length<span class=\"punctuation\">)</span><span class=\"punctuation\">&#123;</span> </span><br><span class=\"line\">  lib.size <span class=\"operator\">&lt;-</span> <span class=\"built_in\">sum</span><span class=\"punctuation\">(</span>x<span class=\"punctuation\">)</span></span><br><span class=\"line\">  rpm <span class=\"operator\">&lt;-</span> 1e6 <span class=\"operator\">*</span> x<span class=\"operator\">/</span>lib.size</span><br><span class=\"line\">  rpkm <span class=\"operator\">&lt;-</span> 1e3 <span class=\"operator\">*</span> rpm<span class=\"operator\">/</span>gene.length</span><br><span class=\"line\">  <span class=\"built_in\">return</span><span class=\"punctuation\">(</span>fpkm<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"TPM\">TPM</h3>\n<p>TPM: Transcript per million<br>\n<img data-src=\"https://thereallda.github.io/2022/01/24/%E7%90%86%E8%AE%BA-%E7%AE%80%E8%BF%B0RPKM-FPKM-AND-TPM/image-20220124111831499.png\" alt=\"公式2\"></p>\n<p>TPM对基因的长度进行了校正，计算比对到基因上的reads/基因长度得到长度校正的表达量 reads per kilobase (RPK)。再以文库中RPK之和作为Scale Factor求出TPM。</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TPM &lt;- function(x, gene.<span class=\"built_in\">length</span>)&#123;</span><br><span class=\"line\">  rpk &lt;- <span class=\"number\">1e3</span> * x/gene.<span class=\"built_in\">length</span></span><br><span class=\"line\">  <span class=\"built_in\">scale</span>.<span class=\"built_in\">factor</span> &lt;- <span class=\"built_in\">sum</span>(rpk)</span><br><span class=\"line\">  tpm &lt;- <span class=\"number\">1e6</span> * rpk/<span class=\"built_in\">scale</span>.<span class=\"built_in\">factor</span></span><br><span class=\"line\">  <span class=\"built_in\">return</span>(tpm)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相比于RPKM使用文库大小（read counts之和）来作为文库校正因子，TPM使用RPK之和作为文库校正因子的好处是考虑了不同样本间的基因长度的分布。因为RPK是一个对基因长度进行校正后的表达量单位，所以RPK之和也不会再带入基因长度的bias。因此，如果需要比较的样本之间转录本分布不一致时（例如不同物种RNA-seq的比较），使用TPM是一个较佳的normalization方案。</p>\n<p>RPKM和TPM这类方法就是为了使不同样本间的总体表达量趋于一致，让不同样本间的基因表达量有可比较性，而TPM能够更好地校正样本间的差异。</p>\n<p>常用的Normalization 方法总结</p>\n<table>\n<thead>\n<tr>\n<th>Normalization method</th>\n<th>描述</th>\n<th>考虑因素</th>\n<th>使用场景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CPM (counts per million)</td>\n<td>使用read counts的总和校正counts</td>\n<td>测序深度</td>\n<td>同一样本组重复样本之间的基因counts比较；不适用于样品内的比较或差异分析</td>\n</tr>\n<tr>\n<td>TPM (transcripts per kilobase million)</td>\n<td>每百万mapped reads中每kb转录本上的reads数</td>\n<td>测序深度和基因长度</td>\n<td>样本内或同一样本组样本之间的基因counts比较； 不适用于差异分析</td>\n</tr>\n<tr>\n<td>RPKM/FPKM (reads/fragments per kilobase of exon per million reads/fragments mapped)</td>\n<td>如TPM</td>\n<td>测序深度和基因长度</td>\n<td>样本内基因间的counts比较; 不适用于样本间比较和差异分析</td>\n</tr>\n<tr>\n<td>DESeq2’s median of ratios [1]</td>\n<td>counts除以样本特异的校正因子，该因子由基因计数相对于每个基因的几何平均值的中位数比率确定</td>\n<td>测序深度及RNA组成</td>\n<td>样本之间的基因counts比较以及差异分析; 不适用于样本内比较</td>\n</tr>\n<tr>\n<td>EdgeR’s trimmed mean of M values (TMM) [2]</td>\n<td>使用样本之间的加权截尾的对数表达量比值的均值进行TMM校正</td>\n<td>测序深度，RNA组成以及基因长度</td>\n<td>样品之间和样品内部的基因counts比较，适用于差异分析</td>\n</tr>\n</tbody>\n</table>\n<p>在进行差异表达分析时，我们实际上并不会用到RPKM/FPKM, TPM，而是使用raw counts给到差异分析的工具。这是由于RPKM/FPKM和TPM都没有考虑到样本间文库组成的差异，因而不适合用于样本间差异分析。</p>\n<h2 id=\"获取基因长度\">获取基因长度</h2>\n<p>计算TPM或RPKM/FPKM等基因表达量时，除了基因的counts信息外，我们还需要知道基因的长度。由于可变剪接的存在，一个基因可能会有多个转录本，在进行基因水平的表达分析时，我们并不会区分各个转录本剪接变体的表达量，而是以基因为单位进行统计。目前，对于基因长度有多种定义，包括：</p>\n<ul class=\"lvl-0\">\n<li class=\"lvl-2\">\n<p>基因最长转录本；</p>\n</li>\n<li class=\"lvl-2\">\n<p>多个转录本长度的平均值；</p>\n</li>\n<li class=\"lvl-2\">\n<p>非重叠外显子长度之和：</p>\n</li>\n<li class=\"lvl-2\">\n<p>非重叠CDS序列长度之和。</p>\n</li>\n</ul>\n<p><img data-src=\"https://thereallda.github.io/2022/02/07/R-Retrieve-Gene-Length/paste-CBFC7C07.png\" alt=\"3\"></p>\n<p>Figure Source: Gene structure</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#使用gtf文件在R中获取基因长度（非重叠外显子长度之和）</span><br><span class=\"line\">#首先，读取计算基因counts时用的GTF文件，并将其转换为TxDb对象；</span><br><span class=\"line\">library(GenomicFeatures)</span><br><span class=\"line\">#一般常用的物种基因注释信息都已经有人构建好TxDb对象，以R包的形式上传到Bioconductor里。我们使用时直接加载、赋值即可。BiocManager::install(&quot;TxDb.Dmelanogaster.UCSC.dm6.ensGene&quot;)</span><br><span class=\"line\">#从本地读取数据库文件 txdb &lt;- makeTxDbFromGFF(&#x27;gencode.vM23.annotation.gtf&#x27;, format=&#x27;gtf&#x27;)</span><br><span class=\"line\">#然后，提取每个基因的外显子注释信息；exons.list.per.gene &lt;- exonsBy(txdb, by=&quot;gene&quot;)</span><br><span class=\"line\">library(TxDb.Dmelanogaster.UCSC.dm6.ensGene)</span><br><span class=\"line\">exons.list.per.gene &lt;- exonsBy(TxDb.Dmelanogaster.UCSC.dm6.ensGene, by=&quot;gene&quot;)</span><br><span class=\"line\">#最后，合并重叠的外显子，计算非重叠外显子的长度作为基因长度（bp）</span><br><span class=\"line\">exonic.gene.sizes &lt;- sum(width(reduce(exons.list.per.gene)))</span><br></pre></td></tr></table></figure>\n<p><code>GenomicFeatures</code>还支持自己手动从指定数据库中构建TxDb对象，例如从 UCSC提取构建的<code>makeTxDbFromUCSC()</code>函数；从BioMart提取构建的<code>makeTxDbFromBiomart()</code>函数等方法可以用作替补方案（没有对应TXDB的R包时）。</p>\n<p><code>tureCounts</code>统计基因counts时，其输出的counts.txt文件中通常会包含一列长度信息Length。也是采用非重叠外显子作为基因长度。</p>\n<h2 id=\"参考：\">参考：</h2>\n<ol>\n<li class=\"lvl-3\">\n<p>理论-简述RPKM-FPKM-AND-TPM | Dean’s blog (<span class=\"exturl\" data-url=\"aHR0cDovL3RoZXJlYWxsZGEuZ2l0aHViLmlv\">thereallda.github.io<i class=\"fa fa-external-link-alt\"></i></span>)</p>\n</li>\n<li class=\"lvl-3\">\n<p>R-获取基因长度 | Dean’s blog (<span class=\"exturl\" data-url=\"aHR0cDovL3RoZXJlYWxsZGEuZ2l0aHViLmlv\">thereallda.github.io<i class=\"fa fa-external-link-alt\"></i></span>)</p>\n</li>\n<li class=\"lvl-3\">\n<p>[R]bioconductor之GenomicFeatures学习 - 简书 (<span class=\"exturl\" data-url=\"aHR0cDovL2ppYW5zaHUuY29t\">jianshu.com<i class=\"fa fa-external-link-alt\"></i></span>)</p>\n</li>\n</ol>\n</div>\n\n\t\t\t<script src=\"https://my.openwrite.cn/js/readmore.js\" type=\"text/javascript\"></script>\n\t\t\t<script>\n\t\t\tvar isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);\n\t\t\tif (!isMobile) {\n\t\t\t    var btw = new BTWPlugin();\n\t\t\t    btw.init({\n\t\t\t        \"id\": \"vip-container\",\n\t\t\t        \"blogId\": \"33502-1730425843713-524\",\n\t\t\t        \"name\": \"虫子的生存笔记\",\n\t\t\t        \"qrcode\": \"https://leaf-miner.pages.dev/image/%E5%85%AC%E4%BC%97%E5%8F%B7.png\",\n\t\t\t        \"keyword\": \"more\"\n\t\t\t    });\n\t\t\t}\n\t\t\t</script>\n\t\t","raw":null,"categories":[{"name":"笔记","path":"api/categories/笔记.json"},{"name":"笔记/科研","path":"api/categories/笔记/科研.json"}],"tags":[{"name":"笔记","path":"api/tags/笔记.json"},{"name":"RNA-seq","path":"api/tags/RNA-seq.json"},{"name":"生信","path":"api/tags/生信.json"},{"name":"R语言","path":"api/tags/R语言.json"},{"name":"测序","path":"api/tags/测序.json"},{"name":"标准化","path":"api/tags/标准化.json"}]}]}